<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Introduction to a Precise SSD Simulator - Archlab SimpleSSD Project 4</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href=".././mdbook-admonish.css">

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Archlab SimpleSSD Project 4</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="introduction-to-a-precise-ssd-simulator"><a class="header" href="#introduction-to-a-precise-ssd-simulator">Introduction to a Precise SSD Simulator</a></h1>
<div id="admonition-cite" class="admonition admonish-quote" role="note" aria-labelledby="admonition-cite-title">
<div class="admonition-title">
<div id="admonition-cite-title">
<p>Cite</p>
</div>
<a class="admonition-anchor-link" href="#admonition-cite"></a>
</div>
<div>
<p>Gouk, D., Kwon, M., Zhang, J., Koh, S., Choi, W., Kim, N. S., ... &amp; Jung, M. (2018, October). Amber: Enabling precise full-system simulation with detailed modeling of all SSD resources. In 2018 51st Annual IEEE/ACM International Symposium on Microarchitecture (MICRO) (pp. 469-481). IEEE.</p>
<p><a href="https://dl.acm.org/doi/10.1109/MICRO.2018.00045">get the pdf</a></p>
</div>
</div>
<p>In this part, we will learn about a precise SSD simulator called Amber/SimpleSSD， which is described by the paper cited above. SimpleSSD models embedded ARM cores, DRAMs, and various flash technologies within an SSD. SimpleSSD also includes the full firmware stack of an SSD, including DRAM cache logic, flash firmware (e.g., FTL and Host Interface Layer (HIL)), and diverse standard protocols (e.g., NVMe). To meet various simulation demands, SimpleSSD supports both standalone (without the host system) and full-system (with the host system) simulation environments. Note that in this project, we will use the standalone version of SimpleSSD (i.e., SimpleSSD-Standalone) to simulate an SSD.
The following content shows the code structure of SimpleSSD, where the code in each subfolder simulates the corresponding component. In this project, we mainly focus on <em><strong>pal</strong></em> and <em><strong>ftl</strong></em> components.</p>
<h2 id="pal-module-in-simplessd"><a class="header" href="#pal-module-in-simplessd">PAL module in SimpleSSD</a></h2>
<p>The PAL in SimpleSSD models the NAND flash. The following functions are provided by PAL.</p>
<pre><code class="language-cpp">class PAL : public StatObject {
 private:
  Parameter param;
  AbstractPAL *pPAL;

  ConfigReader &amp;conf;

 public:
  PAL(ConfigReader &amp;);
  ~PAL();

  void read(Request &amp;, uint64_t &amp;);
  void write(Request &amp;, uint64_t &amp;);
  void erase(Request &amp;, uint64_t &amp;);
};
</code></pre>
<p>PAL implements <code>read</code>, <code>write</code>, and <code>erase</code> functions that receive the requests from the FTL module and return the latency of the corresponding flash operations. Note that you do not need to pay much attention to the details of the PAL. You can view the PAL as a black-box model, that is, you provide reasonable parameters for these PAL functions and get the latency simulated by the black-box model.</p>
<h2 id="ftl-module-in-simplessd"><a class="header" href="#ftl-module-in-simplessd">FTL module in SimpleSSD</a></h2>
<p>We then introduce the FTL implementation in SimpleSSD. As shown in the below codes, <code>simplessd-standalone/simplessd/ftl/abstract_ftl.h</code> defines the FTL abstract class (i.e., <code>AbstractFTL</code>), which contains several virtual functions that need to be implemented by the FTL mapping scheme. The <code>initialize</code> function sets the necessary parameters of the mapping scheme (e.g., the threshold for triggering GC) and <em><strong>warms up</strong></em> the SSD by writing a certain amount of data. The <code>read</code> and <code>write</code> functions describe how the firmware handles read and write requests from the upper layer based on the FTL mapping scheme, respectively. The <code>getStatus</code> function returns some status metrics for the FTL. Note that your hybrid-level mapping scheme should inherit <code>AbstractFTL</code> class and implement all virtual functions required by the abstract class. For convenience, you do not need to implement specific logic for <code>trim</code>, <code>getStatus</code>, and <code>format</code> functions.</p>
<pre><code class="language-cpp">class AbstractFTL : public StatObject {
 protected:
  Parameter &amp;param;
  PAL::PAL *pPAL;
  DRAM::AbstractDRAM *pDRAM;
  Status status;

 public:
  AbstractFTL(Parameter &amp;p, PAL::PAL *l, DRAM::AbstractDRAM *d)
      : param(p), pPAL(l), pDRAM(d) {}
  virtual ~AbstractFTL() {}

  virtual bool initialize() = 0;

  virtual void read(Request &amp;, uint64_t &amp;) = 0;
  virtual void write(Request &amp;, uint64_t &amp;) = 0;
  virtual void trim(Request &amp;, uint64_t &amp;) = 0;

  virtual void format(LPNRange &amp;, uint64_t &amp;) = 0;

  virtual Status *getStatus(uint64_t, uint64_t) = 0;
};
</code></pre>
<p>SimpleSSD provides a default superpage-level FTL mapping scheme, which can be found in <code>simplessd-standalone/simplessd/ftl/page_mapping.hh</code>. <code>PageMapping</code> inherits <code>AbstractFTL</code> and adds some necessary member variables. Specifically, the <code>pPAL</code> is a pointer to the underlying NAND flash model (i.e., parallelism abstraction layer (PAL)), which can be used to obtain the latency of flash operations from a precise flash model. <code>table</code> implements the superpage-level mapping from LPNs to PPNs which are described by a flash superpage number and a page offset within the superpage. Note that the superpage-level is slightly different from pure page-level mapping. <code>blocks</code> stores flash block status information, such as the page valid information, erase count, and write pointer of blocks. <code>freeBlocks</code> is a collection of free blocks, while <code>nFreeBlocks</code> stores the number of free blocks, which is used to check whether GC is needed.</p>
<pre><code class="language-cpp">class PageMapping : public AbstractFTL {
 private:
  PAL::PAL *pPAL;

  ConfigReader &amp;conf;

  std::unordered_map&lt;uint64_t, std::vector&lt;std::pair&lt;uint32_t, uint32_t&gt;&gt;&gt;
      table;
  std::unordered_map&lt;uint32_t, Block&gt; blocks;
  std::list&lt;Block&gt; freeBlocks;
  uint32_t nFreeBlocks;  // For some libraries which std::list::size() is O(n)
  std::vector&lt;uint32_t&gt; lastFreeBlock;
  Bitset lastFreeBlockIOMap;
  uint32_t lastFreeBlockIndex;

  bool bReclaimMore;
  bool bRandomTweak;
  uint32_t bitsetSize;

  struct {
    uint64_t gcCount;
    uint64_t reclaimedBlocks;
    uint64_t validSuperPageCopies;
    uint64_t validPageCopies;
  } stat;
  ...
</code></pre>
<p>The rest functions in <code>PageMapping</code> are as follows. <code>PageMapping</code> simply implements the public interface required by <code>AbstractFTL</code> (e.g., <code>read</code> and <code>write</code>) while placing the detailed logic into the internal functions (e.g., <code>readInternal</code> and <code>writeInternal</code>). To perform GC, <code>PageMapping</code> calculates the weight of each block based on wear-leveling, selects the victim blocks, and executes the GC operation through <code>calculateVictimWeight</code>, <code>selectVictimBlock</code>, and <code>doGarbageCollection</code> function, respectively.</p>
<pre><code class="language-cpp">  ...
  float freeBlockRatio();
  uint32_t convertBlockIdx(uint32_t);
  uint32_t getFreeBlock(uint32_t);
  uint32_t getLastFreeBlock(Bitset &amp;);
  void calculateVictimWeight(std::vector&lt;std::pair&lt;uint32_t, float&gt;&gt; &amp;,
                             const EVICT_POLICY, uint64_t);
  void selectVictimBlock(std::vector&lt;uint32_t&gt; &amp;, uint64_t &amp;);
  void doGarbageCollection(std::vector&lt;uint32_t&gt; &amp;, uint64_t &amp;);

  float calculateWearLeveling();
  void calculateTotalPages(uint64_t &amp;, uint64_t &amp;);

  void readInternal(Request &amp;, uint64_t &amp;);
  void writeInternal(Request &amp;, uint64_t &amp;, bool = true);
  void trimInternal(Request &amp;, uint64_t &amp;);
  void eraseInternal(PAL::Request &amp;, uint64_t &amp;);

 public:
  PageMapping(ConfigReader &amp;, Parameter &amp;, PAL::PAL *, DRAM::AbstractDRAM *);
  ~PageMapping();

  bool initialize() override;

  void read(Request &amp;, uint64_t &amp;) override;
  void write(Request &amp;, uint64_t &amp;) override;
  void trim(Request &amp;, uint64_t &amp;) override;

  void format(LPNRange &amp;, uint64_t &amp;) override;

  Status *getStatus(uint64_t, uint64_t) override;

  void getStatList(std::vector&lt;Stats&gt; &amp;, std::string) override;
  void getStatValues(std::vector&lt;double&gt; &amp;) override;
  void resetStatValues() override;
};
</code></pre>
<h2 id="read-operation-in-pagemapping-ftl-model"><a class="header" href="#read-operation-in-pagemapping-ftl-model">Read operation in <code>PageMapping</code> FTL model</a></h2>
<p>We will use the read operation as an example to introduce how <code>PageMapping</code> operates and how it interacts with the upper and lower layers in SimpleSSD. As shown in the following codes in <code>page_mapping.cc</code>, <code>PageMapping</code> first looks up the mapping table (i.e., <code>table</code>) to translate the LPN to the PPN which is stored in <code>mappingList</code>. It then performs the latency simulation of DRAM access via the <code>pDRAM</code> member.</p>
<pre><code class="language-cpp">void PageMapping::readInternal(Request &amp;req, uint64_t &amp;tick) {
  PAL::Request palRequest(req); // produce pal request
  uint64_t beginAt;
  uint64_t finishedAt = tick;

  auto mappingList = table.find(req.lpn); // find the mapping list

  if (mappingList != table.end()) {
    if (bRandomTweak) {
      pDRAM-&gt;read(&amp;(*mappingList), 8 * req.ioFlag.count(), tick);
    }
    else {
      pDRAM-&gt;read(&amp;(*mappingList), 8, tick); // simulate DRAM access latency
    }
    ...
</code></pre>
<p><code>PageMapping</code> then locates the data required by the upper layer request in the superpage and subsequently constructs the underlying layer request (i.e., <code>palRequest</code>) based on the address of the requested data. Further, <code>PageMapping</code> sends the <code>palRequest</code> to the NAND flash model via the <code>pPAL</code> pointer and obtains the flash read latency in the <code>beginAt</code> variable.</p>
<pre><code class="language-cpp">    ...
    for (uint32_t idx = 0; idx &lt; bitsetSize; idx++) {
      if (req.ioFlag.test(idx) || !bRandomTweak) {
        auto &amp;mapping = mappingList-&gt;second.at(idx); // locate the exact PPN in the mapping list

        if (mapping.first &lt; param.totalPhysicalBlocks &amp;&amp;
            mapping.second &lt; param.pagesInBlock) {
          palRequest.blockIndex = mapping.first; // constructed by PAL::Request palRequest(req);
          palRequest.pageIndex = mapping.second;

          if (bRandomTweak) {
            palRequest.ioFlag.reset();
            palRequest.ioFlag.set(idx);
          }
          else {
            palRequest.ioFlag.set();
          }

          auto block = blocks.find(palRequest.blockIndex);

          if (block == blocks.end()) {
            panic("Block is not in use");
          }

          beginAt = tick;

          block-&gt;second.read(palRequest.pageIndex, idx, beginAt); // update block metadata
          pPAL-&gt;read(palRequest, beginAt); // after this, beginAt stores the finish time of the PAL request

          finishedAt = MAX(finishedAt, beginAt);
        }
      }
    }
    ...
</code></pre>
<p><code>PageMapping</code> updates the request latency by taking the maximum value of the returned read latency. <code>PageMapping</code> also adds the firmware latency to the request latency. But in this project, you can neglect the firmware latency. Finally, the request latency is returned to the upper layer.</p>
<pre><code class="language-cpp">    ...
    tick = finishedAt; // update the tick argument to pass the finish time back, do not need return
    tick += applyLatency(CPU::FTL__PAGE_MAPPING, CPU::READ_INTERNAL);
  }
}
</code></pre>
<div id="admonition-info" class="admonition admonish-info" role="note" aria-labelledby="admonition-info-title">
<div class="admonition-title">
<div id="admonition-info-title">
<p>Info</p>
</div>
<a class="admonition-anchor-link" href="#admonition-info"></a>
</div>
<div>
<p>You may notice that the code checks the <code>bRandomTweak</code> for several times and does different behaviors based on its value. In general, random-tweak enables page-level reads and writes under superpage-level mapping. The <code>idx</code>, <code>ioFlag</code> and <code>bitsetSize</code> are all used for this purpose. The <code>table</code> also saves vectors of block-page pair for each mapping. In this project, we turn this function off, and you do not need to implement any features for this function.</p>
</div>
</div>
<h2 id="write-operation-in-pagemapping-ftl-model"><a class="header" href="#write-operation-in-pagemapping-ftl-model">Write operation in <code>PageMapping</code> FTL model</a></h2>
<p>Then we introduce the write operations performed by <code>PageMapping</code>. Specifically, <code>PageMapping</code> employs <code>Block</code> class to manage the flash blocks currently in use within the SSD. As we describe before, this class encompasses various information, including the validity status of individual pages and LPN associated with each page. Moreover, <code>Block</code> offers multiple functions that emulate real flash operations, such as writing a page to a flash block (<code>write</code> function) and invalidating a page within the flash block (<code>invalidate</code> function). It is crucial to carefully examine its code as FAST frequently queries the flash block information. When <code>PageMapping</code> starts processing a write request, it first invalidates the obsolete page. This process involves finding the previous mapping from table, subsequently locating the corresponding block, and finally invoking the <code>invalidate</code> function.</p>
<pre><code class="language-cpp">void PageMapping::writeInternal(Request &amp;req, uint64_t &amp;tick, bool sendToPAL) {
  PAL::Request palRequest(req);
  std::unordered_map&lt;uint32_t, Block&gt;::iterator block;
  auto mappingList = table.find(req.lpn);
  uint64_t beginAt;
  uint64_t finishedAt = tick;
  bool readBeforeWrite = false;

  if (mappingList != table.end()) { // exists old page on this LPN
    for (uint32_t idx = 0; idx &lt; bitsetSize; idx++) {
      if (req.ioFlag.test(idx) || !bRandomTweak) {
        auto &amp;mapping = mappingList-&gt;second.at(idx);

        if (mapping.first &lt; param.totalPhysicalBlocks &amp;&amp;
            mapping.second &lt; param.pagesInBlock) {
          block = blocks.find(mapping.first);

          // Invalidate current page
          block-&gt;second.invalidate(mapping.second, idx);
        }
      }
    }
  }
  else { // no old page on this LPN
    // Create empty mapping
    auto ret = table.emplace(
        req.lpn,
        std::vector&lt;std::pair&lt;uint32_t, uint32_t&gt;&gt;(
            bitsetSize, {param.totalPhysicalBlocks, param.pagesInBlock}));

    if (!ret.second) {
      panic("Failed to insert new mapping");
    }

    mappingList = ret.first;
  }
  ...
</code></pre>
<p>It proceeds by allocating a free flash page for the upcoming write via <code>getLastFreeBlock</code> function. Notice that to optimize performance, SimpleSSD customizes the allocation policy to suit the flash parallelism. But you can simplify this allocation process in your implementation. This can be achieved by maintaining a linked list of free blocks, where each write utilizes the block at the head, and any reclaimed free block is inserted at the end (i.e., the FIFO policy).</p>
<pre><code class="language-cpp">  ...
  block = blocks.find(getLastFreeBlock(req.ioFlag));

  if (block == blocks.end()) {
    panic("No such block");
  }

  if (sendToPAL) {
    if (bRandomTweak) {
      pDRAM-&gt;read(&amp;(*mappingList), 8 * req.ioFlag.count(), tick);
      pDRAM-&gt;write(&amp;(*mappingList), 8 * req.ioFlag.count(), tick);
    }
    else {
      pDRAM-&gt;read(&amp;(*mappingList), 8, tick); // simulate DRAM access latency. read-modify-write the mapping table.
      pDRAM-&gt;write(&amp;(*mappingList), 8, tick);
    }
  }
</code></pre>
<p>Finally, similar to a read operation, the <code>PageMapping</code> emulates a write operation in the block by validing the flash page and recording the corresponding LPN via write function. Subsequently, a <code>palRequest</code> is dispatched to the underlying PAL to accquire the write latency. It is worth noting that <code>sendToPAL</code> is utlized to distinguish whether the write request originates from the warmup phase or the emulation phase. The warmup phase is specifically designed to replicate the real SSD state after a prolonged period of operation, and it constructs write requests to change the SSD internal states (e.g., FTL mappings). To rapidly reach the steady state, write requests in the warmup phase does not need to be forwarded to the PAL, instead, they solely necessitate modification to metadata within the FTL. Similarly, in your implementation, it is imperative to support the warmup operation to emulate internal states in real SSDs.</p>
<pre><code class="language-cpp">  ...
  for (uint32_t idx = 0; idx &lt; bitsetSize; idx++) {
    if (req.ioFlag.test(idx) || !bRandomTweak) {
      uint32_t pageIndex = block-&gt;second.getNextWritePageIndex(idx); // find an empty page to write
      auto &amp;mapping = mappingList-&gt;second.at(idx);

      beginAt = tick;
      block-&gt;second.write(pageIndex, req.lpn, idx, beginAt);

      // Read old data if needed (Only executed when bRandomTweak = false)
      // Maybe some other init procedures want to perform 'partial-write'
      // So check sendToPAL variable
      if (readBeforeWrite &amp;&amp; sendToPAL) {
        palRequest.blockIndex = mapping.first;
        palRequest.pageIndex = mapping.second;

        // We don't need to read old data
        palRequest.ioFlag = req.ioFlag;
        palRequest.ioFlag.flip();
        pPAL-&gt;read(palRequest, beginAt);
      }

      // update mapping to table
      mapping.first = block-&gt;first;
      mapping.second = pageIndex;

      if (sendToPAL) {
        palRequest.blockIndex = block-&gt;first;
        palRequest.pageIndex = pageIndex;

        if (bRandomTweak) {
          palRequest.ioFlag.reset();
          palRequest.ioFlag.set(idx);
        }
        else {
          palRequest.ioFlag.set();
        }
        pPAL-&gt;write(palRequest, beginAt);
      }
      finishedAt = MAX(finishedAt, beginAt);
    }
  }

  // Exclude CPU operation when initializing
  if (sendToPAL) {
    tick = finishedAt;
    tick += applyLatency(CPU::FTL__PAGE_MAPPING, CPU::WRITE_INTERNAL);
  }
</code></pre>
<h2 id="garbage-collection-in-pagemapping-ftl-model"><a class="header" href="#garbage-collection-in-pagemapping-ftl-model">Garbage collection in <code>PageMapping</code> FTL model</a></h2>
<p>After the write operation finishes, the amount of free blocks may drop below a threshold. Garbage collection is a process to find some victim blocks, move the valid pages from these blocks into free blocks, and earse these blocks, making them free blocks. This process is performed in <code>writeInternal</code>:</p>
<pre><code class="language-cpp">  // GC if needed
  // I assumed that init procedure never invokes GC
  static float gcThreshold = conf.readFloat(CONFIG_FTL, FTL_GC_THRESHOLD_RATIO);

  if (freeBlockRatio() &lt; gcThreshold) {
    if (!sendToPAL) {
      panic("ftl: GC triggered while in initialization");
    }

    std::vector&lt;uint32_t&gt; list;
    uint64_t beginAt = tick;

    selectVictimBlock(list, beginAt);

    debugprint(LOG_FTL_PAGE_MAPPING,
               "GC   | On-demand | %u blocks will be reclaimed", list.size());

    doGarbageCollection(list, beginAt);

    debugprint(LOG_FTL_PAGE_MAPPING,
               "GC   | Done | %" PRIu64 " - %" PRIu64 " (%" PRIu64 ")", tick,
               beginAt, beginAt - tick);

    stat.gcCount++;
    stat.reclaimedBlocks += list.size();
  }
</code></pre>
<p>The <code>selectVictimBlock</code> selects suitable blocks for being victim and push them into the <code>list</code>. The <code>doGarbageCollection</code> performs actual PAL requests. It firstly constructs three lists, recording the read, write and erase requests that are going to be performed, respectively.</p>
<pre><code class="language-cpp">void PageMapping::doGarbageCollection(std::vector&lt;uint32_t&gt; &amp;blocksToReclaim,
                                      uint64_t &amp;tick) {
  PAL::Request req(param.ioUnitInPage);
  std::vector&lt;PAL::Request&gt; readRequests;
  std::vector&lt;PAL::Request&gt; writeRequests;
  std::vector&lt;PAL::Request&gt; eraseRequests;
  std::vector&lt;uint64_t&gt; lpns;
  Bitset bit(param.ioUnitInPage);
  uint64_t beginAt;
  uint64_t readFinishedAt = tick;
  uint64_t writeFinishedAt = tick;
  uint64_t eraseFinishedAt = tick;
  ...
</code></pre>
<p>Then, it builds the requests for each block in the list (i.e., <code>blocksToReclaim</code>). For each valid page in the block, it reads the page out, writes it to a free page, and updates the corresponding metadata. Then it erases all the victim blocks.</p>
<pre><code class="language-cpp">// For all blocks to reclaim, collecting request structure only
  for (auto &amp;iter : blocksToReclaim) {
    auto block = blocks.find(iter);

    if (block == blocks.end()) {
      panic("Invalid block");
    }

    // Copy valid pages to free block
    for (uint32_t pageIndex = 0; pageIndex &lt; param.pagesInBlock; pageIndex++) {
      // Valid?
      if (block-&gt;second.getPageInfo(pageIndex, lpns, bit)) {
        if (!bRandomTweak) {
          bit.set();
        }

        // Retrive free block
        auto freeBlock = blocks.find(getLastFreeBlock(bit));

        // Issue Read
        req.blockIndex = block-&gt;first;
        req.pageIndex = pageIndex;
        req.ioFlag = bit;

        readRequests.push_back(req);

        // Update mapping table
        uint32_t newBlockIdx = freeBlock-&gt;first;

        for (uint32_t idx = 0; idx &lt; bitsetSize; idx++) {
          if (bit.test(idx)) {
            // Invalidate
            block-&gt;second.invalidate(pageIndex, idx);

            auto mappingList = table.find(lpns.at(idx));

            if (mappingList == table.end()) {
              panic("Invalid mapping table entry");
            }

            pDRAM-&gt;read(&amp;(*mappingList), 8 * param.ioUnitInPage, tick);

            auto &amp;mapping = mappingList-&gt;second.at(idx);

            uint32_t newPageIdx = freeBlock-&gt;second.getNextWritePageIndex(idx);

            mapping.first = newBlockIdx;
            mapping.second = newPageIdx;

            freeBlock-&gt;second.write(newPageIdx, lpns.at(idx), idx, beginAt);

            // Issue Write
            req.blockIndex = newBlockIdx;
            req.pageIndex = newPageIdx;

            if (bRandomTweak) {
              req.ioFlag.reset();
              req.ioFlag.set(idx);
            }
            else {
              req.ioFlag.set();
            }

            writeRequests.push_back(req);

            stat.validPageCopies++;
          }
        }

        stat.validSuperPageCopies++;
      }
    }

    // Erase block
    req.blockIndex = block-&gt;first;
    req.pageIndex = 0;
    req.ioFlag.set();

    eraseRequests.push_back(req);
  }
</code></pre>
<p>After this process, all the requests are actually performed.</p>
<pre><code class="language-cpp">  // Do actual I/O here
  // This handles PAL2 limitation (SIGSEGV, infinite loop, or so-on)
  for (auto &amp;iter : readRequests) {
    beginAt = tick;

    pPAL-&gt;read(iter, beginAt);

    readFinishedAt = MAX(readFinishedAt, beginAt);
  }

  for (auto &amp;iter : writeRequests) {
    beginAt = readFinishedAt;

    pPAL-&gt;write(iter, beginAt);

    writeFinishedAt = MAX(writeFinishedAt, beginAt);
  }

  for (auto &amp;iter : eraseRequests) {
    beginAt = readFinishedAt;

    eraseInternal(iter, beginAt);

    eraseFinishedAt = MAX(eraseFinishedAt, beginAt);
  }

  tick = MAX(writeFinishedAt, eraseFinishedAt);
  tick += applyLatency(CPU::FTL__PAGE_MAPPING, CPU::DO_GARBAGE_COLLECTION);
}
</code></pre>
<h2 id="simplessd-setup-and-configuration"><a class="header" href="#simplessd-setup-and-configuration">SimpleSSD Setup and Configuration</a></h2>
<p>The <a href="https://docs.simplessd.org/en/v2.0.12/">SimpleSSD document</a> shows detailed procedures to compile and run SimpleSSD. The first thing you need to do is download SimpleSSD. For your convenience, we've provided a code skeleton for you, so you do not need to download the codes from Github. You can download the package from <a href="https://disk.pku.edu.cn/link/AA8F735492EA4048A282AA5A7B9820B521">PKU Disk</a>.</p>
<p>To build SimpleSSD, you will need CMake. You can install it via the following commands:</p>
<pre><code class="language-sh">sudo apt-get update
sudo apt-get install cmake --fix-missing
</code></pre>
<p>Next, you can setup the workspace and build the program <code>simplessd-standalone</code>:</p>
<pre><code class="language-sh">cd LAB4-CODE-SKELETON
cmake -DDEBUG_BUILD=off .
make -j 8
</code></pre>
<p>After successfully building SimpleSSD, you can use the following command to run SimpleSSD. SimpleSSD runs the workload according to the settings in the Simulation configuration file and SimpleSSD configuration file. It outputs the simulation results and logs to the path specified by the Output directory.</p>
<pre><code class="language-sh"># Usage: simplessd-standalone &lt;Simulation configuration file&gt; &lt;SimpleSSD configuration file&gt; &lt;Output directory&gt;
./simplessd-standalone ./config/sample.cfg ./simplessd/config/sample.cfg ./output
</code></pre>
<p>We've provide the default simulation configuration file and SimpleSSD configuration file, which are located in <code>simplessd-standalone/config/sample.cfg</code> and <code>simplessd-standalone/simplessd/config/sample.cfg</code>, respectively.</p>
<p>The <strong>simulation configuration file</strong> sets the key parameters of the simulation environment. Specifically, <code>LogFile</code>, <code>DebugLogFile</code>, and <code>LatencyLogFile</code> set the output paths of the statistic log, debug log, and latency log, respectively. These log files help you observe the behavior of the SSD. For example, <code>DebugLogFile</code> records the log output during simulation, which can track the processing path of each request, while <code>LatencyLogFile</code> holds statistics for each request in the format of <code>(request ID, address offset, request length, latency (in ps))</code>. Additionally, SimpleSSD provides an I/O generator and a trace replayer to generate workloads for evaluations, and which one to use is decided by <code>Mode</code> in this file. You can use them to evaluate the performance of your FTL scheme implementation. Note that the log file and debug log file can be very large. You can empty the parameter fields to turn off logging.</p>
<pre><code class="language-ini">## Select mode
# Possible values:
#  0: Request generator mode (all configs in [trace] will be ignored)
#  1: Trace replayer mode (all configs in [generator] will be ignored)
Mode = 1

## Statistic log period
# Print statistic log periodically
# 0 means no log printout
# Unit: ms (millisecond) in simulation time (not real time)
LogPeriod = 10

## Log file
# Set output path of statistic log and debug log
# &lt;empty value&gt; means no log printout
# Possible keywords:
#  STDOUT: Standard Output
#  STDERR: Standard Error
LogFile = log.txt
DebugLogFile = debug.txt

## I/O Log file
# Set output path of latency log
# &lt;empty value&gt; means no log printout
LatencyLogFile = latency.csv
</code></pre>
<p>we provide 4 traces obtained from the FIU traces, plus a simple traces for you to debug. These workload exhibits complicated I/O patterns that can check the correctness of your implementation. In addition, workload labels each request as sequential or random. Based on this information and combined with latency data, the correctness of your implementation can be checked. For example, sequential writes should benefit from the SW log block design. You can use these traces by setting <code>Mode = 1</code> and modify the <code>File</code> parameter:</p>
<pre><code class="language-ini">[trace]
## Trace file
File = ./traces/simple
</code></pre>
<p>You will also need to run microbenchmark via the request generator mode. This mode will automatically generate requests according to the configuation. The <code>io_size</code> defines the total size of all requests. <code>readwrite</code> defines the pattern of the requests. Sequential read/write, random read/write and mixed sequential/random I/O are possible configurations. <code>rwmixread</code> defines the ratio of read requests in all requests when running under mixed patterns. <code>blocksize</code> defines the size of each individial request.</p>
<pre><code class="language-ini">[generator]
## This request generator will work similar to Flexible I/O tester
# Definition of Types:
#  str:   String, a sequence of alphanumeric characters
#  int:   SI integer, a sequence of numeric characters
#         Possible suffix (case sensitive):
#          10^3 base: k, m, g, t
#          2^10 base: K, M, G, T
#  float: Floating point number, a sequence of numeric characters
#         with one (or none) of decimal point
#  bool:  Boolean, a true or false value.
#         Possible value (case insensitive):
#          True: Non-zero number, T, True, Y, Yes
#          False: Otherwise
#  time:  SI integer, a sequenced of numeric characters
#         If no suffix provided, value will treated as pico-second.
#         Possible suffix (case sensitive):
#          s, ms, us, ns, ps

## Total size to I/O = int
# Only valid when time_based = false
io_size = 128M   # 16 * 2^20 bytes

## Type of I/O = str
# Possible values:
#  read:      Sequential read
#  write:     Sequential write
#  randread:  Random read
#  randwrite: Random write
#  readwrite: Mixed sequential I/O
#  randrw:    Mixed random I/O
readwrite = write

## Percentage of mixed I/O = float
# If readwrite is not readwrite nor randrw, this value will ignored
# 0 &lt;= value &lt;= 1
rwmixread = 0.5  # 50% of read I/O

## Block size = int
blocksize = 4K
</code></pre>
<p>Other parameters in the simulation configuration file can be left unchanged during this project.</p>
<p>The <strong>SimpleSSD configuration file</strong> sets the key parameters of the simulated SSD, including the embedded cores, NVMe, FTL, ICL, and PAL. This file provides a detailed explanation for each parameter, and you can refer to this file to learn how to set the parameters. Nevertheless, the only necessary parameter in this project is <code>MappingMode</code>. You can leave others unchanged.</p>
<pre><code class="language-ini">[ftl]
## Set mapping method
# Possible values:
#  0: Page level mapping
#  1: FAST mapping
MappingMode = 1

</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../proj4/ssd.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../proj4/task.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../proj4/ssd.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../proj4/task.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
